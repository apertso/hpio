// --- –û–ë–©–ï–ï –û–ü–ò–°–ê–ù–ò–ï ---
// –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ (Cron Jobs) ‚Äî —ç—Ç–æ –≥–∞—Ä–∞–Ω—Ç –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ –∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –≤ —Å–∏—Å—Ç–µ–º–µ.
// –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é –∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏,
// –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ø–æ–ª–Ω—è—é—Ç –ª–æ–≥–∏–∫—É, —Å—Ä–∞–±–∞—Ç—ã–≤–∞—é—â—É—é –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
// –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞—Ö–æ–¥–∏—Ç –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, cron-–∑–∞–¥–∞—á–∏ –æ–±–µ—Å–ø–µ—á–∞—Ç
// –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –µ–≥–æ –ø–ª–∞—Ç–µ–∂–µ–π –∏ –≤ –±—É–¥—É—â–µ–º –æ—Ç–ø—Ä–∞–≤—è—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.

import cron from "node-cron";
import logger from "../config/logger";
// –ò–º–ø–æ—Ä—Ç —Å–µ—Ä–≤–∏—Å–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–¥–∞—á–∏
import {
  updateOverdueStatuses,
  generateNextRecurrentPayments,
  cleanupOrphanedSeries,
} from "../services/paymentService";
import {
  executeWithTaskLock,
  TASK_UPDATE_OVERDUE,
  TASK_GENERATE_RECURRING,
  TASK_CLEANUP_ORPHANED_SERIES,
} from "../services/taskLockService";
import {
  sendPaymentReminderEmail,
  // Placeholder for future push service
} from "../services/emailService";
import db from "../models";
import { Op } from "sequelize";
import { trace, SpanStatusCode, Span } from "@opentelemetry/api"; // üëà Import OpenTelemetry

// --- OpenTelemetry Tracer ---
const tracer = trace.getTracer("cron-job-tracer");
// ----------------------------

const setupCronJobs = () => {
  // –ó–ê–î–ê–ß–ê 1: –ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π.
  // –ß–¢–û –î–ï–õ–ê–ï–¢: –ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ –ø–ª–∞—Ç–µ–∂–∏ —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º 'upcoming', —É –∫–æ—Ç–æ—Ä—ã—Ö —Å—Ä–æ–∫ –æ–ø–ª–∞—Ç—ã —É–∂–µ –ø—Ä–æ—à–µ–ª, –∏ –º–µ–Ω—è–µ—Ç –∏—Ö —Å—Ç–∞—Ç—É—Å –Ω–∞ 'overdue'.
  // –ü–û–ß–ï–ú–£ –ù–£–ñ–ù–û: –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ö–∞–Ω–∏–∑–º, –∫–æ—Ç–æ—Ä—ã–π –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–≤–æ–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Å—Ä–æ—á–µ–∫ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ.
  // –í–†–ï–ú–Ø: –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 00:05 (—Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –ø–æ–ª—É–Ω–æ—á–∏, —á—Ç–æ–±—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—á–µ—Ä–∞—à–Ω–∏–µ –¥–∞—Ç—ã).
  cron.schedule("5 0 * * *", async () => {
    logger.info(`Cron: Attempting to run ${TASK_UPDATE_OVERDUE}`);
    try {
      const affectedCount = await executeWithTaskLock(
        TASK_UPDATE_OVERDUE,
        updateOverdueStatuses
      );
      if (affectedCount !== undefined) {
        logger.info(
          `Cron: Finished ${TASK_UPDATE_OVERDUE}. Affected ${affectedCount} payments.`
        );
      } else {
        logger.info(
          `Cron: Task ${TASK_UPDATE_OVERDUE} was skipped (likely already in progress or interval not met).`
        );
      }
    } catch (error) {
      logger.error(`Cron: Error in ${TASK_UPDATE_OVERDUE}`, error);
    }
  });

  // –ó–ê–î–ê–ß–ê 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π –≤ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–µ—Ä–∏—è—Ö.
  // –ß–¢–û –î–ï–õ–ê–ï–¢: –ù–∞—Ö–æ–¥–∏—Ç –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Ä–∏–∏ –∏ —Å–æ–∑–¥–∞–µ—Ç –¥–ª—è –Ω–∏—Ö —Å–ª–µ–¥—É—é—â–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–ª–∞—Ç–µ–∂–∞, –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω.
  // –ü–û–ß–ï–ú–£ –ù–£–ñ–ù–û: –≠—Ç–æ "—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞" –∏ –º–µ—Ö–∞–Ω–∏–∑–º —Å–∞–º–æ–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è. –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å–æ–∑–¥–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –ø–ª–∞—Ç–µ–∂ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ,
  // –Ω–æ —ç—Ç–∞ –∑–∞–¥–∞—á–∞ –Ω—É–∂–Ω–∞, –µ—Å–ª–∏:
  // 1. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–≥–æ –Ω–µ –∑–∞—Ö–æ–¥–∏–ª –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –Ω–µ –æ—Ç–º–µ—á–∞–ª –ø–ª–∞—Ç–µ–∂–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–º–∏.
  // 2. –ü—Ä–æ–∏–∑–æ—à–µ–ª —Å–±–æ–π, –∏ –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞.
  // –≠—Ç–∞ –∑–∞–¥–∞—á–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ —Ü–µ–ø–æ—á–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–µ—Ä–≤–µ—Ç—Å—è.
  // –í–†–ï–ú–Ø: –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 01:00 (–ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤).
  cron.schedule("0 1 * * *", async () => {
    logger.info(`Cron: Attempting to run ${TASK_GENERATE_RECURRING}`);
    try {
      const result = await executeWithTaskLock(
        TASK_GENERATE_RECURRING,
        generateNextRecurrentPayments
      );
      if (result) {
        logger.info(
          `Cron: Finished ${TASK_GENERATE_RECURRING}. Created ${result.createdCount} payments for ${result.checkedSeriesCount} series.`
        );
      } else {
        logger.info(
          `Cron: Task ${TASK_GENERATE_RECURRING} was skipped (likely already in progress or interval not met).`
        );
      }
    } catch (error) {
      logger.error(`Cron: Error in ${TASK_GENERATE_RECURRING}`, error);
    }
  });

  // –ó–ê–î–ê–ß–ê 3: –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ –ø–ª–∞—Ç–µ–∂–∞—Ö.
  // –ß–¢–û –î–ï–õ–ê–ï–¢: –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–µ –Ω–∞—Å—Ç—É–ø–∏–ª–æ –ª–∏ —É –∫–æ–≥–æ-—Ç–æ –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Ä–µ–º—è –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.
  // –ï—Å–ª–∏ –Ω–∞—Å—Ç—É–ø–∏–ª–æ, –Ω–∞—Ö–æ–¥–∏—Ç –≤—Å–µ –ø–ª–∞—Ç–µ–∂–∏ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–ø–ª–∞—á–µ–Ω—ã —Å–µ–≥–æ–¥–Ω—è –∏ –ø–æ–º–µ—á–µ–Ω—ã –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è,
  // –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (Email/Push).
  // –í–†–ï–ú–Ø: –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É (—Ç–æ–ª—å–∫–æ –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ).
  if (process.env.NODE_ENV === "production") {
    cron.schedule("* * * * *", async () => {
      let span: Span;
      try {
        span = tracer.startSpan("notification-sending-job");
      } catch (e) {
        logger.error("[OpenTelemetry] Failed to start span:", e);
        return; // –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –Ω–µ –∑–∞–ø—É—Å–∫–∞—Ç—å "–æ—Å–ª–µ–ø–ª—ë–Ω–Ω—É—é" –ª–æ–≥–∏–∫—É
      }

      try {
        // 1. –ü–æ–ª—É—á–∞–µ–º –í–°–ï–• –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –∫–æ—Ç–æ—Ä—ã—Ö –≤–∫–ª—é—á–µ–Ω—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –±—É–¥–µ—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∞ –≤ –∫–æ–¥–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, —Ç–∞–∫ –∫–∞–∫ MS SQL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç IANA-—Ç–∞–π–º–∑–æ–Ω—ã (–Ω–∞–ø—Ä., 'Europe/Moscow').
        const potentialUsers = await db.User.findAll({
          where: {
            notificationMethod: { [Op.ne]: "none" },
            isVerified: true,
          },
        });

        const now = new Date();

        // 2. –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –∫–æ–¥–µ, –ø—Ä–æ–≤–µ—Ä—è—è –∏—Ö –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è.
        const usersToNotify = potentialUsers.filter((user) => {
          try {
            // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ —Ç–∞–π–º–∑–æ–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ "HH:mm"
            const timeInZone = new Intl.DateTimeFormat("en-GB", {
              timeZone: user.timezone,
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            }).format(now);

            // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –≤—Ä–µ–º–µ–Ω–µ–º, —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            return timeInZone === user.notificationTime;
          } catch (e) {
            logger.error(
              `Invalid timezone for user ${user.id}: ${user.timezone}`
            );
            return false; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–π —Ç–∞–π–º–∑–æ–Ω–æ–π
          }
        });

        span.setAttribute("users.to_notify.count", usersToNotify.length);
        if (usersToNotify.length === 0) {
          span.end();
          return;
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);

        for (const user of usersToNotify) {
          const paymentsToRemind = await db.Payment.findAll({
            where: {
              userId: user.id,
              remind: true,
              status: { [Op.in]: ["upcoming", "overdue"] },
              dueDate: {
                [Op.gte]: today,
                [Op.lt]: tomorrow,
              },
            },
          });

          if (paymentsToRemind.length === 0) {
            continue;
          }

          logger.info(
            `Sending ${paymentsToRemind.length} reminders to ${user.email} via ${user.notificationMethod}`
          );

          for (const payment of paymentsToRemind) {
            if (user.notificationMethod === "email") {
              await sendPaymentReminderEmail(
                user.email,
                user.name,
                payment.title,
                payment.amount,
                payment.dueDate
              );
            } else if (user.notificationMethod === "push") {
              // TODO: Implement push notification logic
              logger.warn(
                `Push notification for user ${user.id} is not implemented yet.`
              );
            }
          }
        }

        span.setStatus({ code: SpanStatusCode.OK });
      } catch (error) {
        logger.error("Cron: Error in notification sending job", error);
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: (error as Error).message,
        });
      } finally {
        span.end();
      }
    });
  } else {
    logger.info(
      "Skipping notification cron job in non-production environment."
    );
  }

  // –ó–ê–î–ê–ß–ê 4: –û—á–∏—Å—Ç–∫–∞ "–æ—Å–∏—Ä–æ—Ç–µ–≤—à–∏—Ö" —Å–µ—Ä–∏–π.
  // –ß–¢–û –î–ï–õ–ê–ï–¢: –ù–∞—Ö–æ–¥–∏—Ç –∏ —É–¥–∞–ª—è–µ—Ç –∑–∞–ø–∏—Å–∏ –æ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–µ—Ä–∏—è—Ö, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∏ –æ–¥–∏–Ω –ø–ª–∞—Ç–µ–∂.
  // –ü–û–ß–ï–ú–£ –ù–£–ñ–ù–û: –ï—Å–ª–∏ –≤—Å–µ –ø–ª–∞—Ç–µ–∂–∏ —Å–µ—Ä–∏–∏ –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –≤—Ä—É—á–Ω—É—é, —Å–∞–º–∞ —Å–µ—Ä–∏—è –º–æ–∂–µ—Ç –æ—Å—Ç–∞—Ç—å—Å—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö. –≠—Ç–∞ –∑–∞–¥–∞—á–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —á–∏—Å—Ç–æ—Ç—É –¥–∞–Ω–Ω—ã—Ö.
  // –í–†–ï–ú–Ø: –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 02:00 (–ø–æ—Å–ª–µ –¥—Ä—É–≥–∏—Ö –æ—Å–Ω–æ–≤–Ω—ã—Ö –∑–∞–¥–∞—á).
  cron.schedule("0 2 * * *", async () => {
    logger.info(`Cron: Attempting to run ${TASK_CLEANUP_ORPHANED_SERIES}`);
    try {
      const deletedCount = await executeWithTaskLock(
        TASK_CLEANUP_ORPHANED_SERIES,
        cleanupOrphanedSeries
      );
      if (deletedCount !== undefined) {
        logger.info(
          `Cron: Finished ${TASK_CLEANUP_ORPHANED_SERIES}. Cleaned up ${deletedCount} series.`
        );
      } else {
        logger.info(
          `Cron: Task ${TASK_CLEANUP_ORPHANED_SERIES} was skipped (likely already in progress or interval not met).`
        );
      }
    } catch (error) {
      logger.error(`Cron: Error in ${TASK_CLEANUP_ORPHANED_SERIES}`, error);
    }
  });

  logger.info("Cron jobs scheduled with task locking.");
};

export { setupCronJobs };
